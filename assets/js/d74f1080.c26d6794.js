"use strict";(self.webpackChunkinterview_guide=self.webpackChunkinterview_guide||[]).push([[328],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(o,".").concat(m)]||u[m]||p[m]||l;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2134:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:2},i="Basic Concepts",s={unversionedId:"java/oops",id:"java/oops",title:"Basic Concepts",description:"Object Oriented Programming",source:"@site/docs/java/oops.mdx",sourceDirName:"java",slug:"/java/oops",permalink:"/java/oops",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Java Notes",permalink:"/java"},next:{title:"Types & Operators",permalink:"/java/operators"}},o={},c=[{value:"Object Oriented Programming",id:"object-oriented-programming",level:2},{value:"Class",id:"class",level:3},{value:"Object",id:"object",level:3},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Abstraction",id:"abstraction",level:3},{value:"Polymorphism",id:"polymorphism",level:3},{value:"Method Overloading &amp; Overriding in Java",id:"method-overloading--overriding-in-java",level:4},{value:"Rule for overriding",id:"rule-for-overriding",level:4},{value:"Covariant return type",id:"covariant-return-type",level:4},{value:"Abstract Class",id:"abstract-class",level:3},{value:"Interface",id:"interface",level:3},{value:"Marker Interface",id:"marker-interface",level:4},{value:"Inheritance",id:"inheritance",level:3},{value:"Types of Inheritance",id:"types-of-inheritance",level:4},{value:"Super Class &amp; Sub class reference",id:"super-class--sub-class-reference",level:3},{value:"How multiple inheritance indirectly achieved in Java?",id:"how-multiple-inheritance-indirectly-achieved-in-java",level:4},{value:"Constructor",id:"constructor",level:2},{value:"Understanding Signature of main() method",id:"understanding-signature-of-main-method",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"basic-concepts"},"Basic Concepts"),(0,r.kt)("h2",{id:"object-oriented-programming"},"Object Oriented Programming"),(0,r.kt)("h3",{id:"class"},"Class"),(0,r.kt)("p",null,"Collection of similar properties of object. Class is user defined data type which contains properties and methods"),(0,r.kt)("h3",{id:"object"},"Object"),(0,r.kt)("p",null,"Example/Instance of a class. It exist in real world."),(0,r.kt)("p",null,"How to create an object instance?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax")," : ",(0,r.kt)("strong",{parentName:"p"},"new")," constructor","_","method"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"E.g.")," new Student()"),(0,r.kt)("h3",{id:"encapsulation"},"Encapsulation"),(0,r.kt)("p",null,"Binds together the data and functions ","&"," provide security"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Achieved using POJO class")," (declare all variable as private ","&"," create public getter, setter methods)"),(0,r.kt)("h3",{id:"abstraction"},"Abstraction"),(0,r.kt)("p",null,"Hide certain details and only show the essential features of the object."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Achieved using Interface ","&"," Abstract Class")),(0,r.kt)("h3",{id:"polymorphism"},"Polymorphism"),(0,r.kt)("p",null,"Poly - Many Forms. Same name can be used for different operations"),(0,r.kt)("p",null,"Achieved using ",(0,r.kt)("strong",{parentName:"p"},"Method Overloading ","&"," Method Overriding"),"."),(0,r.kt)("h4",{id:"method-overloading--overriding-in-java"},"Method Overloading ","&"," Overriding in Java"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Overloading")),(0,r.kt)("p",null,"Methods have same names but different number or type or order of parameters. Overloading is determined at the compile time. It","'","s otherwise called static or compile time polymorphism"),(0,r.kt)("p",null,"E.g."),(0,r.kt)("p",null,"display(String name)"),(0,r.kt)("p",null,"display(String name, int number)"),(0,r.kt)("p",null,"display(int number, String name)"),(0,r.kt)("p",null,"Method won","'","t be considered overloaded, if the return type is the only difference between two methods."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Overriding")),(0,r.kt)("p",null,"A child class implements the method with same signature as a method in a parent class."),(0,r.kt)("p",null,"In method overriding both the super ","&"," sub class have same method signature, compile doesn","'","t figure out which method to call at compile-time. In this case, JVM decides which method to call at runtime that","'","s why it","'","s called dynamic polymorphism."),(0,r.kt)("h4",{id:"rule-for-overriding"},"Rule for overriding"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Overridden Method (Super class method)")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Overriding Method (Sub class method)")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"If public"),(0,r.kt)("td",{parentName:"tr",align:null},"should be public")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"If protected"),(0,r.kt)("td",{parentName:"tr",align:null},"should be protected or public")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"If default (no access specifier)"),(0,r.kt)("td",{parentName:"tr",align:null},"should be protected or public or default")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"If private"),(0,r.kt)("td",{parentName:"tr",align:null},"can","'","t be overridden")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"If static"),(0,r.kt)("td",{parentName:"tr",align:null},"can","'","t be overridden")))),(0,r.kt)("h4",{id:"covariant-return-type"},"Covariant return type"),(0,r.kt)("p",null,"Generally when we override a method, the signature has to be same for both methods. But there is a privilege to change the return type of the overriding method."),(0,r.kt)("p",null,"The return type we change should be the subtype of the return type of overridden method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Covariant Return Type" showLineNumbers',title:'"Covariant',Return:!0,'Type"':!0,showLineNumbers:!0},"class Student {\n\n}\n\n\nclass ScienceStudent extends Student {\n\n    // highlight-next-line\n    public Student getStudent() {\n        return new Student();\n    }\n}\n\nclass DoctorateStudent extends ScienceStudent {\n\n    // highlight-next-line\n    @Override\n    // highlight-next-line\n    public ScienceStudent getStudent() {\n        return new Student();\n    }\n}\n")),(0,r.kt)("p",null,"In above case, we are trying to override the ",(0,r.kt)("inlineCode",{parentName:"p"},"getStudent()")," method from ",(0,r.kt)("inlineCode",{parentName:"p"},"ScienceStudent")," class in ",(0,r.kt)("inlineCode",{parentName:"p"},"DoctorateStudent")," class. In order to override, the signature should of the methods has to same in both super and sub class."),(0,r.kt)("p",null,"In the above case, super class ",(0,r.kt)("inlineCode",{parentName:"p"},"getStudent()")," method returns ",(0,r.kt)("inlineCode",{parentName:"p"},"Student")," object. sub class ",(0,r.kt)("inlineCode",{parentName:"p"},"getStudent()")," method returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"ScienceStudent")," object. Still it is a legal overriding. Its valid because ScienceStudent is sub class of Student object."),(0,r.kt)("h3",{id:"abstract-class"},"Abstract Class"),(0,r.kt)("p",null,"Abstract class is class which may or may not contains abstract methods. The child extends Abstract class, it should give define the abstract methods."),(0,r.kt)("p",null,"Abstract Class can have"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Abstract methods and normal methods"),(0,r.kt)("li",{parentName:"ul"},"Static, final ","&"," normal variables")),(0,r.kt)("p",null,"We cannot create object for abstract class"),(0,r.kt)("h3",{id:"interface"},"Interface"),(0,r.kt)("p",null,"An interface is a reference type, similar to a class ","&"," it","'","s used to achieve 100 % abstraction"),(0,r.kt)("p",null,"Interface can have"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Only abstract methods, and by default all methods are public"),(0,r.kt)("li",{parentName:"ul"},"Only  public static final variables //constants"),(0,r.kt)("li",{parentName:"ul"},"Cannot have static or final methods in interface")),(0,r.kt)("p",null,"Class which extends Interface should give implementation for all methods in interface"),(0,r.kt)("p",null,"If the class which extends interface is an abstract class, it need not give definition for all interface methods instead class which extends the abstract class has to define the undefined methods in interface"),(0,r.kt)("h4",{id:"marker-interface"},"Marker Interface"),(0,r.kt)("p",null,"An interface with no methods is called Marker Interface"),(0,r.kt)("p",null,"E.g. Serializable, Clonnable are marker interfaces"),(0,r.kt)("p",null,"These interfaces are used to indicate something to compiler or JVM that the class implementing any of these interface have some special behaviour"),(0,r.kt)("h3",{id:"inheritance"},"Inheritance"),(0,r.kt)("p",null,"Inheriting the parent properties / behaviour. Represents the ",(0,r.kt)("strong",{parentName:"p"},"IS A relationship")," in real world. Achieved using ",(0,r.kt)("strong",{parentName:"p"},"extends")," keyword"),(0,r.kt)("p",null,"Possible inheritance hierarchy"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"One Interface can extend another interface"),(0,r.kt)("li",{parentName:"ul"},"One class can implements any number of interface"),(0,r.kt)("li",{parentName:"ul"},"One abstract class can implements any number of interface")),(0,r.kt)("h4",{id:"types-of-inheritance"},"Types of Inheritance"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Single Inheritance")),(0,r.kt)("p",null,"When a class extends another class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Single Inheritance"',title:'"Single','Inheritance"':!0},"class A {\n\n}\n\nclass B extends A {\n\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Multilevel Inheritance")),(0,r.kt)("p",null,"One class which inherits property of another class which itself inherited class from another super class is called Multilevel inheritance"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Multilevel Inheritance"',title:'"Multilevel','Inheritance"':!0},"class A {\n\n}\n\nclass B extends A {\n\n}\n\nclass C extends B {\n\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Multiple Inheritance")),(0,r.kt)("p",null,"Java doesnot support multiple inheritance directly. In general, multiple inheritance means one class extends property from more than one super class."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Why multiple inheritance not supported in Java?")),(0,r.kt)("p",null,"When a class inherit from two or more classes, there is a chance two methods with same signature exist in both the super classes. So compiler will face ambiguity situation on choosing between the two method implementation. So in Java, multiple inheritance is not supported by default."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Multiple Inheritance"',title:'"Multiple','Inheritance"':!0},"class A {\n\n}\n\nclass B {\n\n}\n\nclass C extends A,B {\n\n// Error not possible\n\n}\n")),(0,r.kt)("h3",{id:"super-class--sub-class-reference"},"Super Class & Sub class reference"),(0,r.kt)("p",null,"A Super class reference can hold both super class object & sub class Object"),(0,r.kt)("p",null,"E.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Inheritance Hierarchy"',title:'"Inheritance','Hierarchy"':!0},"class Animal {\n\n}\n\nclass Monkey extends Animal {\n\n}\n\nclass Human extends Monkey {\n\n}\n\nclass Tiger extends Animal {\n\n}\n\n\nAnimal a = new Animal() // Valid\nAnimal b = new Monkey() // Valid\nAnimal c = new Human()  // Valid\nAnimal d = new Tiger()  // Valid\n\n\nMonkey m1 = new Monkey()  // Valid\nMonkey m2 = new Human()  // Valid\n\nMonkey m1 = new Animal() // Invalid\nHuman h1 = new Monkey()  // Invalid\nTiger t = new Animal()   // Invalid\n")),(0,r.kt)("p",null,"So when we create a Sub class object, we can store it in Sub class reference as well as Super class reference as demonstrated in above examples"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Advantages of above approach")),(0,r.kt)("p",null,"Writing Generic method definitions is possible"),(0,r.kt)("p",null,"E.g"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Student")," is the super class which contains the common functionality called ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateGPA()"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class Student {\n\n    String name;\n    int[] subjectMarks = new int[5];\n\n    Student(String name, int[] subjectMarks) {\n        this.name = name;\n        this.subjectMarks = subjectMarks;\n    }\n\n    void calculateGPA() {\n        int total = 0;\n        for (int i = 0; i < subjectMarks.length; i++) {\n            total = total + subjectMarks[i];\n        }\n        double average = total/5;\n        System.out.println("Your GPA is " + average);\n    }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ArtsStudent"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ScienceStudent"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"EngineeringStudent")," are subclasses of Student class"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ArtsStudent")," has one extra method - ",(0,r.kt)("inlineCode",{parentName:"p"},"writeTheoryThesis()")," which is not in parent class Student"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'class ArtsStudent extends Student {\n\n    ArtsStudent(String name, int[] subjectMarks) {\n        super(name, subjectMarks);\n    }\n\n    void writeTheoryThesis() {\n        System.out.println("Write theory thesis");\n    }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ScienceStudent")," has one extra method - ",(0,r.kt)("inlineCode",{parentName:"p"},"research()")," which is not in parent class Student"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'class ScienceStudent extends Student {\n\n    ScienceStudent(String name, int[] subjectMarks) {\n        super(name, subjectMarks);\n    }\n\n    void research() {\n        System.out.println("Research & Learn");\n    }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"EngineeringStudent")," has one extra method - ",(0,r.kt)("inlineCode",{parentName:"p"},"writeTechnicalThesis()")," which is not in parent class Student"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'class EngineeringStudent extends Student {\n\n    EngineeringStudent(String name, int[] subjectMarks) {\n        super(name, subjectMarks);\n    }\n\n    void writeTechnicalThesis() {\n        System.out.println("Just go to college");\n    }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"College")," class has a method called ",(0,r.kt)("inlineCode",{parentName:"p"},"prepareMarksheet()")," which needs GPA to prepare the same. So it simply accepts Student as parameter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},' // Extract from College class\nvoid prepareFinalMarkSheet(Student student) {\n  System.out.println("Student name is " + student.name);\n  student.calculateGPA();\n}\n')),(0,r.kt)("p",null,"Advantage here is, since the parameter is mentioned as ",(0,r.kt)("inlineCode",{parentName:"p"},"Student"),", we can pass ArtsStudent, ScienceStudent, EngineeringStudent"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'int[] artsMarksS1 = {89, 98, 100, 89, 75};\nint[] artsMarksS2 = {98, 98, 100, 89, 75};\nint[] artsMarksS3 = {67, 98, 100, 89, 75};\nint[] artsMarksS4 = {47, 98, 100, 89, 75};\n\nStudent s1 = new ArtsStudent("Nithya", artsMarksS1);\nStudent s2 = new ScienceStudent("Paari", artsMarksS2);\nStudent s3 = new EngineeringStudent("Sri", artsMarksS3);\nStudent s4 = new EngineeringStudent("Gopika", artsMarksS4);\n\nCollege college = new College();\ncollege.prepareFinalMarkSheet(s1);\ncollege.prepareFinalMarkSheet(s2);\ncollege.prepareFinalMarkSheet(s3);\ncollege.prepareFinalMarkSheet(s4);\n')),(0,r.kt)("p",null,"Disadvantage is, when we store a Sub class object in Super class reference, we can't call the subclass specific methods anymore"),(0,r.kt)("p",null,"E.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Student s1 = new ArtsStudent("Nithya", artsMarksS1);\ns1.calculateGPA() // Valid\n// s1.writeTheoryThesis() // Invalid because s1 is Student reference which can\'t call Arts Student method\n')),(0,r.kt)("h4",{id:"how-multiple-inheritance-indirectly-achieved-in-java"},"How multiple inheritance indirectly achieved in Java?"),(0,r.kt)("p",null,"In Java, multiple inheritance is indirectly implemented using Interface. So a class can implement more than one interface at time."),(0,r.kt)("p",null,"If two interfaces have methods with same s"),(0,r.kt)("h2",{id:"constructor"},"Constructor"),(0,r.kt)("p",null,"When you create a new instance of the class, Constructor will be called automatically."),(0,r.kt)("p",null,"This can be used to initialize values in the class"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Restrictions")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Same name as Class Name"),(0,r.kt)("li",{parentName:"ul"},"Only one Default Constructor"),(0,r.kt)("li",{parentName:"ul"},"Constructor Overloading is possible"),(0,r.kt)("li",{parentName:"ul"},"When we use Parameterized Constructor, Default Constructor is mandatory")),(0,r.kt)("h2",{id:"understanding-signature-of-main-method"},"Understanding Signature of main() method"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"main")," method is the default method called by the ",(0,r.kt)("inlineCode",{parentName:"p"},"JVM (Java Virtual Machine)")," when we execute our Program. Main method has to follow the below signature mandatorily"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public static void main(String arg[]) {\n\n}\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"syntax"),(0,r.kt)("th",{parentName:"tr",align:null},"meaning"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public"),(0,r.kt)("td",{parentName:"tr",align:null},"Since the ",(0,r.kt)("inlineCode",{parentName:"td"},"main")," method is called by ",(0,r.kt)("inlineCode",{parentName:"td"},"JVM")," which is installed somewhere else in your machine")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"static"),(0,r.kt)("td",{parentName:"tr",align:null},"Since ",(0,r.kt)("inlineCode",{parentName:"td"},"JVM")," doesn't want to create Object for your class, to access ",(0,r.kt)("inlineCode",{parentName:"td"},"main")," method, we mentioned static. So JVM can access ",(0,r.kt)("inlineCode",{parentName:"td"},"main")," using class name itself")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"void"),(0,r.kt)("td",{parentName:"tr",align:null},"Since the ",(0,r.kt)("inlineCode",{parentName:"td"},"main")," method is called by the ",(0,r.kt)("inlineCode",{parentName:"td"},"JVM"),", we don't want to return anything to JVM. Hence return type is ",(0,r.kt)("inlineCode",{parentName:"td"},"void"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"main"),(0,r.kt)("td",{parentName:"tr",align:null},"method name has to be ",(0,r.kt)("inlineCode",{parentName:"td"},"main")," as mandated by the Java programming language")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"String args[]"),(0,r.kt)("td",{parentName:"tr",align:null},"String array of parameters which a program can accept, we will discuss this in detail later")))))}p.isMDXComponent=!0}}]);